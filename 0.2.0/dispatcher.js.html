<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dispatcher.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Command.html">Command</a><ul class='methods'><li data-type='method'><a href="Command.html#.usage">usage</a></li><li data-type='method'><a href="Command.html#hasPermission">hasPermission</a></li><li data-type='method'><a href="Command.html#isEnabledIn">isEnabledIn</a></li><li data-type='method'><a href="Command.html#isUsable">isUsable</a></li><li data-type='method'><a href="Command.html#reload">reload</a></li><li data-type='method'><a href="Command.html#run">run</a></li><li data-type='method'><a href="Command.html#setEnabledIn">setEnabledIn</a></li><li data-type='method'><a href="Command.html#usage">usage</a></li></ul></li><li><a href="CommandArgument.html">CommandArgument</a><ul class='methods'><li data-type='method'><a href="CommandArgument.html#obtain">obtain</a></li><li data-type='method'><a href="CommandArgument.html#parse">parse</a></li><li data-type='method'><a href="CommandArgument.html#validate">validate</a></li></ul></li><li><a href="CommandBuilder.html">CommandBuilder</a><ul class='methods'><li data-type='method'><a href="CommandBuilder.html#hasPermission">hasPermission</a></li><li data-type='method'><a href="CommandBuilder.html#info">info</a></li><li data-type='method'><a href="CommandBuilder.html#register">register</a></li><li data-type='method'><a href="CommandBuilder.html#run">run</a></li></ul></li><li><a href="CommandDispatcher.html">CommandDispatcher</a><ul class='methods'><li data-type='method'><a href="CommandDispatcher.html#addInhibitor">addInhibitor</a></li><li data-type='method'><a href="CommandDispatcher.html#removeInhibitor">removeInhibitor</a></li></ul></li><li><a href="CommandFormatError.html">CommandFormatError</a></li><li><a href="CommandGroup.html">CommandGroup</a><ul class='methods'><li data-type='method'><a href="CommandGroup.html#isEnabledIn">isEnabledIn</a></li><li data-type='method'><a href="CommandGroup.html#setEnabledIn">setEnabledIn</a></li></ul></li><li><a href="CommandMessage.html">CommandMessage</a><ul class='methods'><li data-type='method'><a href="CommandMessage.html#.parseArgs">parseArgs</a></li><li data-type='method'><a href="CommandMessage.html#anyUsage">anyUsage</a></li><li data-type='method'><a href="CommandMessage.html#code">code</a></li><li data-type='method'><a href="CommandMessage.html#delete">delete</a></li><li data-type='method'><a href="CommandMessage.html#direct">direct</a></li><li data-type='method'><a href="CommandMessage.html#edit">edit</a></li><li data-type='method'><a href="CommandMessage.html#editCode">editCode</a></li><li data-type='method'><a href="CommandMessage.html#isMentioned">isMentioned</a></li><li data-type='method'><a href="CommandMessage.html#obtainArgs">obtainArgs</a></li><li data-type='method'><a href="CommandMessage.html#parseArgs">parseArgs</a></li><li data-type='method'><a href="CommandMessage.html#pin">pin</a></li><li data-type='method'><a href="CommandMessage.html#reply">reply</a></li><li data-type='method'><a href="CommandMessage.html#run">run</a></li><li data-type='method'><a href="CommandMessage.html#say">say</a></li><li data-type='method'><a href="CommandMessage.html#unpin">unpin</a></li><li data-type='method'><a href="CommandMessage.html#usage">usage</a></li></ul></li><li><a href="CommandoClient.html">CommandoClient</a></li><li><a href="CommandRegistry.html">CommandRegistry</a><ul class='methods'><li data-type='method'><a href="CommandRegistry.html#buildCommand">buildCommand</a></li><li data-type='method'><a href="CommandRegistry.html#findCommands">findCommands</a></li><li data-type='method'><a href="CommandRegistry.html#findGroups">findGroups</a></li><li data-type='method'><a href="CommandRegistry.html#registerCommand">registerCommand</a></li><li data-type='method'><a href="CommandRegistry.html#registerCommands">registerCommands</a></li><li data-type='method'><a href="CommandRegistry.html#registerCommandsIn">registerCommandsIn</a></li><li data-type='method'><a href="CommandRegistry.html#registerDefaultCommands">registerDefaultCommands</a></li><li data-type='method'><a href="CommandRegistry.html#registerDefaultGroups">registerDefaultGroups</a></li><li data-type='method'><a href="CommandRegistry.html#registerDefaults">registerDefaults</a></li><li data-type='method'><a href="CommandRegistry.html#registerEvalObject">registerEvalObject</a></li><li data-type='method'><a href="CommandRegistry.html#registerEvalObjects">registerEvalObjects</a></li><li data-type='method'><a href="CommandRegistry.html#registerGroup">registerGroup</a></li><li data-type='method'><a href="CommandRegistry.html#registerGroups">registerGroups</a></li><li data-type='method'><a href="CommandRegistry.html#reregisterCommand">reregisterCommand</a></li><li data-type='method'><a href="CommandRegistry.html#resolveCommand">resolveCommand</a></li><li data-type='method'><a href="CommandRegistry.html#resolveGroup">resolveGroup</a></li></ul></li><li><a href="FriendlyError.html">FriendlyError</a></li></ul><h3>Externals</h3><ul><li><a href="external-Channel.html">Channel</a></li><li><a href="external-ClientOptions.html">ClientOptions</a></li><li><a href="external-Guild.html">Guild</a></li><li><a href="external-GuildMember.html">GuildMember</a></li><li><a href="external-GuildResolvable.html">GuildResolvable</a></li><li><a href="external-Message.html">Message</a></li><li><a href="external-StringResolvable.html">StringResolvable</a></li><li><a href="external-User.html">User</a></li></ul><h3>Events</h3><ul><li><a href="CommandoClient.html#event:commandBlocked">commandBlocked</a></li><li><a href="CommandoClient.html#event:commandError">commandError</a></li><li><a href="CommandoClient.html#event:commandPrefixChange">commandPrefixChange</a></li><li><a href="CommandoClient.html#event:commandRegister">commandRegister</a></li><li><a href="CommandoClient.html#event:commandReregister">commandReregister</a></li><li><a href="CommandoClient.html#event:commandRun">commandRun</a></li><li><a href="CommandoClient.html#event:commandStatusChange">commandStatusChange</a></li><li><a href="CommandoClient.html#event:groupRegister">groupRegister</a></li><li><a href="CommandoClient.html#event:groupStatusChange">groupStatusChange</a></li><li><a href="CommandoClient.html#event:unknownCommand">unknownCommand</a></li></ul><h3>Interfaces</h3><ul><li><a href="GuildExtension.html">GuildExtension</a><ul class='methods'><li data-type='method'><a href="GuildExtension.html#.applyToClass">applyToClass</a></li><li data-type='method'><a href="GuildExtension.html#commandUsage">commandUsage</a></li><li data-type='method'><a href="GuildExtension.html#isCommandEnabled">isCommandEnabled</a></li><li data-type='method'><a href="GuildExtension.html#isGroupEnabled">isGroupEnabled</a></li><li data-type='method'><a href="GuildExtension.html#setCommandEnabled">setCommandEnabled</a></li><li data-type='method'><a href="GuildExtension.html#setGroupEnabled">setGroupEnabled</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">dispatcher.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('events').EventEmitter;
const escapeRegex = require('escape-string-regexp');
const CommandMessage = require('./command-message');

/** Handles parsing messages and running commands from them */
class CommandDispatcher extends EventEmitter {
	/**
	 * @param {CommandoClient} client - Client the dispatcher is for
	 * @param {CommandRegistry} registry - Registry the dispatcher will use
	 */
	constructor(client, registry) {
		super();

		/**
		 * Client this dispatcher handles messages for
		 * @type {CommandoClient}
		 */
		this.client = client;

		/**
		 * Registry this dispatcher uses
		 * @type {CommandRegistry}
		 */
		this.registry = registry;

		/**
		 * Functions that can block commands from running
		 * @type {Set&lt;function>}
		 */
		this.inhibitors = new Set();

		this._commandPatterns = {};
		this._results = new Map();
		this._awaiting = new Set();
	}

	/**
	 * A function that can block the usage of a command - these functions are passed the command message that is
	 * triggering the command. They should return `false` if the command should *not* be blocked. If the command *should*
	 * be blocked, they should return one of the following:
	 * - A single string identifying the reason the command is blocked
	 * - An array of the above string as element 0, and a response promise or `null` as element 1
	 * @typedef {function} Inhibitor
	 */

	/**
	 * Adds an inhibitor
	 * @param {Inhibitor} inhibitor - The inhibitor function to add
	 * @return {boolean} Whether the addition was successful
	 * @example
	 * client.dispatcher.addInhibitor(msg => {
	 *   if(blacklistedUsers.has(msg.author.id)) return 'blacklisted';
	 * });
	 * @example
	 * client.dispatcher.addInhibitor(msg => {
	 * 	if(!coolUsers.has(msg.author.id)) return ['cool', msg.reply('You\'re not cool enough!')];
	 * });
	 */
	addInhibitor(inhibitor) {
		if(typeof inhibitor !== 'function') throw new TypeError('The inhibitor must be a function.');
		if(this.inhibitors.has(inhibitor)) return false;
		this.inhibitors.add(inhibitor);
		return true;
	}

	/**
	 * Removes an inhibitor
	 * @param {Inhibitor} inhibitor - The inhibitor function to remove
	 * @return {boolean} Whether the removal was successful
	 */
	removeInhibitor(inhibitor) {
		if(typeof inhibitor !== 'function') throw new TypeError('The inhibitor must be a function.');
		return this.inhibitors.delete(inhibitor);
	}

	// eslint-disable-next-line valid-jsdoc
	/**
	 * Handle a new message or a message update
	 * @param {Message} message - The message to handle
	 * @param {Message} [oldMessage] - The old message before the update
	 * @return {Promise&lt;void>}
	 * @private
	 */
	async handleMessage(message, oldMessage) {
		if(message.author.bot) return;
		else if(this.client.options.selfbot &amp;&amp; message.author.id !== this.client.user.id) return;
		else if(!this.client.options.selfbot &amp;&amp; message.author.id === this.client.user.id) return;

		// Ignore messages from users that the bot is already waiting for input from
		if(this._awaiting.has(message.author.id + message.channel.id)) return;

		// Make sure the edit actually changed the message content
		if(oldMessage &amp;&amp; message.content === oldMessage.content) return;

		// Parse the message, and get the old result if it exists
		const cmdMsg = this.parseMessage(message);
		let oldCmdMsg;
		if(oldMessage) {
			oldCmdMsg = this._results.get(oldMessage.id);
			if(cmdMsg &amp;&amp; oldCmdMsg) {
				cmdMsg.responses = oldCmdMsg.responses;
				cmdMsg.responsePositions = oldCmdMsg.responsePositions;
			}
		}

		// Run the command, or reply with an error
		let responses;
		if(cmdMsg) {
			const inhibited = this.inhibit(cmdMsg);

			if(!inhibited) {
				if(cmdMsg.command) {
					if(message.guild &amp;&amp; !message.guild.isCommandEnabled(cmdMsg.command)) {
						responses = await cmdMsg.reply(`The \`${cmdMsg.command.name}\` command is disabled.`);
					} else if(!oldMessage || typeof oldCmdMsg !== 'undefined') {
						responses = await cmdMsg.run();
						if(typeof responses === 'undefined') responses = null;
					}
				} else {
					/**
					 * Emitted when an unknown command is triggered
					 * @event CommandoClient#unknownCommand
					 * @param {CommandMessage} message - Command message that triggered the command
					 */
					this.client.emit('unknownCommand', cmdMsg);
					if(this.client.options.unknownCommandResponse) {
						responses = await cmdMsg.reply(
							`Unknown command. Use ${cmdMsg.anyUsage(
								'help',
								message.guild ? undefined : null,
								message.guild ? undefined : null
							)} to view the list of all commands.`
						);
					} else {
						responses = null;
					}
				}
			} else {
				responses = await inhibited[1];
			}

			cmdMsg._finalize(responses);
		} else if(oldCmdMsg) {
			oldCmdMsg._finalize(null);
			if(this.client.options.nonCommandEditable &lt;= 0) this._results.delete(message.id);
		}

		this.cacheCommandMessage(message, oldMessage, cmdMsg, responses);
	}

	/**
	 * Inhibits a command message
	 * @param {CommandMessage} cmdMsg - Command message to inhibit
	 * @return {?Array} [reason, ?response]
	 * @private
	 */
	inhibit(cmdMsg) {
		for(const inhibitor of this.inhibitors) {
			const inhibited = inhibitor(cmdMsg);
			if(inhibited) {
				this.client.emit('commandBlocked', cmdMsg, inhibited instanceof Array ? inhibited[0] : inhibited);
				return inhibited instanceof Array ? inhibited : [inhibited, undefined];
			}
		}
		return null;
	}

	/**
	 * Caches a command message to be editable
	 * @param {Message} message - Triggering message
	 * @param {Message} oldMessage - Triggering message's old version
	 * @param {CommandMessage} cmdMsg - Command message to cache
	 * @param {Message|Message[]} responses - Responses to the message
	 * @private
	 */
	cacheCommandMessage(message, oldMessage, cmdMsg, responses) {
		if(this.client.options.commandEditableDuration > 0) {
			if(cmdMsg || this.client.options.nonCommandEditable) {
				if(responses !== null) {
					this._results.set(message.id, cmdMsg);
					if(!oldMessage) {
						setTimeout(() => { this._results.delete(message.id); }, this.client.options.commandEditableDuration * 1000);
					}
				} else {
					this._results.delete(message.id);
				}
			}
		}
	}

	/**
	 * Parses a message to find details about command usage in it
	 * @param {Message} message - The message
	 * @return {?CommandMessage}
	 * @private
	 */
	parseMessage(message) {
		// Find the command to run by patterns
		for(const command of this.client.registry.commands) {
			if(!command.patterns) continue;
			for(const pattern of command.patterns) {
				const matches = pattern.exec(message.content);
				if(matches) return new CommandMessage(message, command, null, matches);
			}
		}

		// Find the command to run with default command handling
		const gp = message.guild ? message.guild.id : 'global';
		if(!this._commandPatterns[gp]) this.buildCommandPattern(message.guild);
		let cmdMsg = this.matchDefault(message, this._commandPatterns[gp], 2);
		if(!cmdMsg &amp;&amp; !message.guild &amp;&amp; !this.client.options.selfbot) cmdMsg = this.matchDefault(message, /^([^\s]+)/i);
		return cmdMsg;
	}

	/**
	 * Matches a message against a guild command pattern
	 * @param {Message} message - The message
	 * @param {RegExp} pattern - The pattern to match against
	 * @param {number} commandNameIndex - The index of the command name in the pattern matches
	 * @return {?CommandMessage}
	 * @private
	 */
	matchDefault(message, pattern, commandNameIndex = 1) {
		const matches = pattern.exec(message.content);
		if(!matches) return null;
		const commands = this.client.registry.findCommands(matches[commandNameIndex], true);
		if(commands.length !== 1 || !commands[0].defaultHandling) return new CommandMessage(message, null);
		const argString = message.content.substring(matches[1].length + (matches[2] ? matches[2].length : 0));
		return new CommandMessage(message, commands[0], argString);
	}

	/**
	 * Creates a regular expression to match the command prefix and name in a message
	 * @param {?Guild} guild - The Guild that the message is from
	 * @return {RegExp}
	 * @private
	 */
	buildCommandPattern(guild) {
		let prefix = guild ? guild.commandPrefix : this.client.options.commandPrefix;
		if(prefix === 'none') prefix = '';
		const escapedPrefix = escapeRegex(prefix);
		const prefixPatternPiece = prefix ? `${escapedPrefix}\\s*|` : '';
		const pattern = new RegExp(
			`^(${prefixPatternPiece}&lt;@!?${this.client.user.id}>\\s+(?:${escapedPrefix})?)([^\\s]+)`, 'i'
		);
		this._commandPatterns[guild ? guild.id : 'global'] = pattern;
		this.client.emit('commandPatternBuilt', guild, prefix, pattern);
		return pattern;
	}
}

module.exports = CommandDispatcher;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Wed Oct 19 2016 00:22:33 GMT-0400 (Eastern Daylight Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
